# 5426. 重新规划路线

---

## 题目描述

`n` 座城市，从 `0` 到 `n-1` 编号，其间共有 `n-1` 条路线。因此，要想在两座不同城市之间旅行只有唯一一条路线可供选择（路线网形成一颗树）。去年，交通运输部决定重新规划路线，以改变交通拥堵的状况。

路线用 `connections` 表示，其中 `connections[i] = [a, b]` 表示从城市 `a` 到 `b` 的一条有向路线。

今年，城市 `0` 将会举办一场大型比赛，很多游客都想前往城市 `0`。

请你帮助重新规划路线方向，使每个城市都可以访问城市 `0`。返回需要变更方向的最小路线数。

题目数据保证每个城市在重新规划路线方向后都能到达城市 `0`。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

---

## 琐记

没做出来，图相关的题目还是做得少了。

做这道题时要是把题图旋转 90 度，当成一棵树，可能思路会更加清晰。

---

## DFS

**1.建图**

图 `g` 使用了默认字典，它的 `default_factory` 参数是 `list`，所以在访问字典中没有的键时，会先创建一个空列表。
`g` 中的键对应结点编号，从 `0` 到 `n - 1`。
`g` 中的值是一个列表，由与键结点相连的所有边的另一端结点的编号组成，同时还保有方向关系，所以该列表由二元组组成。
二元组的第一个值即是另一端结点的编号，第二个值如果为 `1`，代表 `键 -> 值` 这条边是真实存在的，第二个值如果为 `0`，代表 `键 -> 值` 这条边并不存在，而是一个反向的 `值 -> 键` 的关系。

举个例子，首先从 `connections` 中读入了一条边 `[1, 2]`，实际指向应为 `1 -> 2`。
在 `g` 中处理键 `1`，把 `2` 添加到键 `1` 对应的值列表中，方向关系为 `1`，得到 `g = {1: [(2, 1)]}`。
然后在 `g` 中处理键 `2`，把 `1` 添加到键 `2` 对应的值列表中，方向关系是反向，应为 `0`，得到 `g = {1: [(2, 1)], 2: [(1, 0)]}`。

又读取了一条边 `3 -> 2`，依照上面的方式处理，此时的图为 `g = {1: [(2, 1)], 2: [(1, 0), (3, 0)], 3: [(2, 1)]}`。

**2.深搜**

自顶向下开始深搜，传递两个变量，一个是当前结点编号，另外一个是父结点编号。

如果当前结点到另一端结点的方向关系为 `1`，说明这条边的方向需要反转，同时计数加一。

当然，对于父结点，需要跳过计数循环，因为父结点到当前结点的边在上一次的 `dfs` 中已经计算过了。

```python3
class Solution:
    def minReorder(self, n: int, connections: List[List[int]]) -> int:
        # 建图
        # 1 代表存在从 s -> t 的边
        # 0 代表不存在从 t -> s 的边
        g = defaultdict(list)
        for e in connections:
            s, t = [*e]
            g[s].append([t, 1])
            g[t].append([s, 0])
        
        # 别加这个，没必要，且更慢
        # @lru_cache(None)
        def dfs(node, father):
            ans = 0
            # 遍历与当前结点相连的每一条边
            for e in g[node]:
                # 与当前结点相连的每一条边中，存储着另一端结点及边的方向
                other, direction = [*e]
                # 如果另一端结点是父结点，继续循环
                # 因为父结点是否需要逆转方向，已经计算过了
                if (other == father):
                    continue
                # 当前的边不是与父结点相连的边，并且是出去的边
                # 那么就要把当前方向逆转，也就是加上 direction 即可
                ans += dfs(other, node) + direction
            return ans

        return dfs(0, -1)
```

**运行结果**

> 执行结果：通过
> 执行用时 :376 ms, 在所有 Python3 提交中击败了100.00% 的用户
> 内存消耗 :41.4 MB, 在所有 Python3 提交中击败了100.00%的用户

另外，我还试了一下 `@lru_cache`，发现速度居然更慢了。想想也对，这个 `dfs` 的过程中每条边只遍历一次，并没有需要记忆化的东西，所以加上这个反而会拖慢速度。

---

`2020.5.31`
