# 696. 计数二进制子串

## 题目描述

给定一个字符串 `s`，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。

重复出现的子串要计算它们出现的次数。

**示例 1 :**

```text
输入: "00110011"
输出: 6
解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。

请注意，一些重复出现的子串要计算它们出现的次数。

另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。
```

**示例 2 :**

```text
输入: "10101"
输出: 4
解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。
```

**注意：**

- `s.length` 在1到50,000之间。
- `s` 只包含“0”或“1”字符。

> 来源：力扣（LeetCode）  
> 链接：<https://leetcode-cn.com/problems/count-binary-substrings>  
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

---

## 统计连续数量，累加相邻最小值

经过观察发现，只要计算出连续 `0` 或者 `1` 的个数，然后比较相邻连续个数的最小值，最终把它们加起来即可。

比如 `00110011` 对应的连续 `0` 或者 `1` 的个数为 `[2, 2, 2, 2]`，相邻最小值为 `[2, 2, 2]`，相加得到答案 `6`。

我在代码中是通过记录分割点来统计连续 `01` 数量的，也可以直接计算出连续 `01` 数量。

```python
class Solution:
    def countBinarySubstrings(self, s: str) -> int:
        n = len(s)
        dq = deque([0])
        res = 0

        for i in range(len(s) - 1):
            if s[i] != s[i + 1]:
                dq.append(i + 1)
        dq.append(n)

        for i in range(1, len(dq) - 1):
            res += min(dq[i] - dq[i - 1], dq[i + 1] - dq[i])

        return res

```

**运行结果**：

> 执行结果：通过  
> 执行用时：368 ms, 在所有 Python3 提交中击败了9.09% 的用户  
> 内存消耗：14.7 MB, 在所有 Python3 提交中击败了5.49% 的用户

---

`2020.08.10`
