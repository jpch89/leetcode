# 1371. 每个元音包含偶数次的最长子字符串

---

## 题目描述

给你一个字符串 `s`，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 'a'，'e'，'i'，'o'，'u' ，在子字符串中都恰好出现了偶数次。

**示例 1：**

> 输入：s = "eleetminicoworoep"
> 输出：13
> 解释：最长子字符串是 "leetminicowor" ，它包含 e，i，o 各 2 个，以及 0 个 a，u 。

**示例 2：**

> 输入：s = "leetcodeisgreat"
> 输出：5
> 解释：最长子字符串是 "leetc" ，其中包含 2 个 e 。

**示例 3：**

> 输入：s = "bcbcbc"
> 输出：6
> 解释：这个示例中，字符串 "bcbcbc" 本身就是最长的，因为所有的元音 a，e，i，o，u 都出现了 0 次。

**提示：**

- `1 <= s.length <= 5 x 10^5`
- `s` 只包含小写英文字母。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

---

## 琐记

第二次遇到状态压缩，前缀和也是第二次见了，这俩拼起来还是不会写。

---

## 思路分析：状态压缩、前缀和

个人理解：**所谓状态压缩，其实就是对状态进行编码，建立状态与数字之间的映射。**

将元音字母出现次数的奇偶状态进行状态压缩，`a` 对应于二进制位的第 `0` 位，`e` 对应于二进制位的第 `1` 位，`i` 对应于二进制位的第 `2` 位，`o` 对应于二进制位的第 `3` 位，`u` 对应于二进制位的第 `4` 位。

由于一共有 `5` 个字母，所以一共需要 `5` 个二进制位，当字母所对应的二进制位为 `0` 时，表示该字母出现了偶数次，当字母所对应的二进制位为 `1` 时，表示该字母出现了奇数次。

如果用十进制来表示状态的取值范围，就是从 `0` 到 `2 ** 5 - 1= 31`，一共 `32` 种状态，也就是二进制的 `0b00000` 到 `0b11111`。

其中状态 `0b00000` 就是我们期望的状态，表示所有元音字母都出现了偶数次。

对于字符串 `leeco`，我们模拟一下指针从头走到尾时的元音字母奇偶性状态，用 `i` 记录当前下标：

- 初始状态 `state = 0b00000`
- `i = 0` 时，新来的字母 `l` 是辅音字母，对元音字母奇偶性没有任何影响，所以 `state = 0b00000`
- `i = 1` 时，新来的字母 `e` 是元音字母，对应于二进制位的第 `1` 位，所以更新状态为 `state = 0b00010`
- `i = 2` 时，新来的字母 `e` 是元音字母，此时累计已经出现了两个 `e` 了，所以是偶数个 `e`，应该把 `e` 对应的二进制位置 `0`，所以更新状态为 `state = 0b00000`
- `i = 3` 时，新来的字母 `c` 是辅音字母，状态不变，还是 `state = 0b00000`
- `i = 4` 时，新来的字母 `o` 是元音字母，对应二进制位的第 `3` 位，所以更新状态为 `0b01000`

在这一过程中发现，计算元音字母奇偶性状态时，可以使用异或运算：

- `i = 1` 时，状态为 `0b00010`
- `i = 2` 时，新来的字母为 `e`，对应的状态掩码为 `1 << 1 == 0b00010`，用之前的状态与元音字母的掩码进行异或，即可得到当前状态
- 即 `0b00010(之前状态) ^ 0b00010(e的掩码) = 0b00000(当前状态)`
- 假如其他二进制位为 `1` 时，与字母 `e` 的掩码 `0b00010` 进行异或是不会发生任何改变的，这是异或运算的性质。

但是现在有个问题，我们只计算出了以 `i = 0` 开头的子串状态，从题目上看，子串的起始位是可以变动的，这可怎么办？

这时就需要用到前缀和思想：`states[l, r]= states[0, r] - states[0, l - 1]`。
其中 `states[l, r]` 表示 `s` 的子串区间为 `[l, r]` 时的元音字母奇偶性状态。

之前说过，满足要求的 `states[l, r]` 应该是等于 `0` 的，也就是说，每当我们计算出一个 `states[r]`，就需要去查表，看看之前有没有出现过同样的状态，如果出现过，就可以让 `states[r] - states[l - 1] == 0` 成立，也就找到了满足条件的子串。如果没有出现过，就要记录当前状态的下标，以便后面如果出现了同样的状态，就可以凑成一个满足条件的子串。由于期望满足条件的子串越长越好，所以只需要记录状态**第一次**出现的下标就可以了。

字典（哈希表）是一个适合建立状态第一次出现的下标的数据结构，由于我们进行了状态压缩，也就是将状态进行了编码，且编码连续，于是列表（数组）也是一个不错的选择。

需要注意的是初始化的值，对于状态 `0b00000`，在下标为 `-1` 的时候就存在了，所以要把 `states[0]` 设置为 `-1`。

也可以带入一个例子考虑，对于只有一个辅音字母的字符串 `'d'`，在 `i = 0` 时，读入 `d`，此时状态为 `0b00000`，用它减去 `state[0]` 得到 `1`，也就是我们要的答案。

至此，这道题目的思路就出来了。

---

## 使用数组存储元音字母奇偶性状态

```python3
class Solution:
    def findTheLongestSubstring(self, s: str) -> int:
        # vowels = {k: 1 << v for k in 'aeiou' for v in range(5)}
        vowels = {k: 1 << v for k, v in zip('aeiou', range(5))}
        states = [-1] + [None] * 31
        state = ans = 0
        for i, ch in enumerate(s):
            state ^= vowels.get(ch, 0)
            if states[state] is None:
                states[state] = i
            else:
                ans = max(ans, i - states[state])
        return ans
```

> 执行结果：通过
> 执行用时 :632 ms, 在所有 Python3 提交中击败了67.86% 的用户
> 内存消耗 :19.7 MB, 在所有 Python3 提交中击败了100.00%的用户

---

## 使用字典存储元音字母奇偶性状态

```python3
class Solution:
    def findTheLongestSubstring(self, s: str) -> int:
        vowels, states = {k: 1 << v for k, v in zip('aeiou', range(5))}, {0: -1}
        ans = state = 0
        for i, ch in enumerate(s):
            state ^= vowels.get(ch, 0)
            ans = max(ans, i - states.setdefault(state, i))
        return ans
```

> 执行结果：通过
> 执行用时 :640 ms, 在所有 Python3 提交中击败了66.07% 的用户
> 内存消耗 :19.8 MB, 在所有 Python3 提交中击败了100.00%的用户

---

## 参考题解

- [C++ 前缀和+状态压缩 详解](https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/solution/c-qian-zhui-he-zhuang-tai-ya-suo-xiang-jie-by-yizh/)
写的通俗易懂

---

`2020.5.20`
