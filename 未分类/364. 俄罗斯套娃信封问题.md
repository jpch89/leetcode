# 力扣 364. 俄罗斯套娃信封问题

![](https://cdn.jsdelivr.net/gh/jpch89/PicBed/img/202104041033%20%E5%8A%9B%E6%89%A3%20364.%20%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98%2000.png)

---

## 题目描述

给你一个二维整数数组 `envelopes`，其中 `envelopes[i] = [wi, hi]`，表示第 `i` 个信封的宽度和高度。

当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。

请计算**最多能有多少个**信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。

**注意**：不允许旋转信封。

**示例 1：**

```text
输入：envelopes = [[5,4],[6,4],[6,7],[2,3]]
输出：3
解释：最多信封的个数为 3, 组合为: [2,3] => [5,4] => [6,7]。
```

**示例 2：**

```text
输入：envelopes = [[1,1],[1,1],[1,1]]
输出：1
```

**提示：**

- `1 <= envelopes.length <= 5000`
- `envelopes[i].length == 2`
- `1 <= wi, hi <= 10^4`

> 来源：力扣（LeetCode）  
> 链接：<https://leetcode-cn.com/problems/russian-doll-envelopes>  
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

---

## 动态规划

按照第一维升序、第二维降序排序，再对第二维求 `LIS` 结果即可。关于如何求 `LIS` 的长度，可以参考 [[202104041000 力扣 300. 最长递增子序列|力扣 300. 最长递增子序列]]。

仅对第一维升序，如果输入为 `[[1, 1], [1, 2], [1, 3]]`，此时如果单单考虑第二维，发现 `LIS` 长度为 `3`。但实际上由于第一维都一样，所以只能组成长度为 `1` 的 `LIS`。但是如果在排序的时候，对第二维降序排序，则得到 `[[1, 3], [1, 2], [1, 1]]`，此时只考虑第二维，则可以得到正确结果。

```python
class Solution:
    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:
        envs = sorted(envelopes, key=lambda x: (x[0], -x[1]))
        hs = [*map(lambda x: x[1], envs)]
        n  = len(hs)
        f = [1] * n
        for i in range(n):
            for j in range(i):
                if hs[i] > hs[j]:
                    f[i] = max(f[i], f[j] + 1)
        return max(f)
```

**运行结果**：

> 执行结果：通过  
> 执行用时：7308 ms, 在所有 Python3 提交中击败了51.55% 的用户  
> 内存消耗：16.4 MB, 在所有 Python3 提交中击败了43.44% 的用户

---

`2021.4.4`
