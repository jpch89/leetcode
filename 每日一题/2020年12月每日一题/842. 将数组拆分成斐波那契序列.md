# 842. 将数组拆分成斐波那契序列

![842. 将数组拆分成斐波那契序列](https://cdn.jsdelivr.net/gh/jpch89/PicBed/img/202012081037%20842.%20%E5%B0%86%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86%E6%88%90%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%BA%8F%E5%88%97%2000.png)

## 题目描述

给定一个数字字符串 `S`，比如 `S = "123456579"`，我们可以将它分成斐波那契式的序列 `[123, 456, 579]`。

形式上，斐波那契式序列是一个非负整数列表 `F`，且满足：

- `0 <= F[i] <= 2^31 - 1`，（也就是说，每个整数都符合 `32` 位有符号整数类型）；
- `F.length >= 3`；
- 对于所有的 `0 <= i < F.length - 2`，都有 `F[i] + F[i+1] = F[i+2]` 成立。

另外，请注意，将字符串拆分成小块时，每个块的数字一定不要以零开头，除非这个块是数字 `0` 本身。

返回从 `S` 拆分出来的任意一组斐波那契式的序列块，如果不能拆分则返回 `[]`。

**示例 1**：

```text
输入："123456579"
输出：[123,456,579]
```

**示例 2**：

```text
输入: "11235813"
输出: [1,1,2,3,5,8,13]
```

**示例 3**：

```text
输入: "112358130"
输出: []
解释: 这项任务无法完成。
```

**示例 4**：

```text
输入："0123"
输出：[]
解释：每个块的数字不能以零开头，因此 "01"，"2"，"3" 不是有效答案。
```

**示例 5**：

```text
输入: "1101111"
输出: [110, 1, 111]
解释: 输出 [11,0,11,11] 也同样被接受。
```

**提示**：

1. `1 <= S.length <= 200`
2. 字符串 `S` 中只含有数字。

> 来源：力扣（LeetCode）  
> 链接：<https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence>  
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

---

## 带返回值的回溯 + 剪枝

这个回溯带有返回值，用于判断是否已经找到了可行解，只要找到一个可行解就可以返回。解题思路就是从字符串中取数，遍历 `S` 字符串来拼接出当前项，同时验证当前项是否满足斐波那契数列的特征。

这里有三个剪枝条件，在注释中也有注明：

1. 任意一项不能大于 `2 ^ 31 - 1`。
2. 如果当前项大于前两项之和，没有继续计算的必要，因为后面只会越来越大，可以提前结束循环。
3. 当前项以 `0` 开始，且不是 `0` 本身，这种数字不满足题目要求。

```python
class Solution:
    def splitIntoFibonacci(self, S: str) -> List[int]:
        m = 2 ** 31 - 1
        res = []
        n = len(S)
        def backtrack(pos):
            # 基线条件
            if pos == n:
                return len(res) > 2
            # 递归条件
            s = 0
            for i in range(pos, n):
                s = s * 10 + int(S[i])
                # 剪枝条件 1：当前项不能大于最大值
                if s > m:
                    break
                # 剪枝条件 2：当前项大于前两项之和，没有继续计算的必要
                if len(res) > 2 and s > res[-1] + res[-2]:
                    break
                # 剪枝条件 3：当前项以 0 开始，且不是 0 本身
                if S[pos] == '0' and i > pos:
                    break
                if len(res) < 2 or res[-1] + res[-2] == s:
                    # 保存现场
                    res.append(s)
                    # 回溯
                    if backtrack(i + 1):
                        return True
                    # 恢复现场
                    res.pop()
            return False
        return res if backtrack(0) else []
```

**运行结果**：

> 执行结果：通过  
> 执行用时：40 ms, 在所有 Python3 提交中击败了98.42% 的用户  
> 内存消耗：13.6 MB, 在所有 Python3 提交中击败了6.63% 的用户

最后，这道题给我的启示是，如果不会写剪枝条件可以先略过，专注于把回溯主体写出来，之后再进行优化。

---

`2020.12.08`
