# 62. 不同路径

![62. 不同路径](https://cdn.jsdelivr.net/gh/jpch89/PicBed/img/202012091051%2062.%20%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%2000.png)

## 动态规划

- 状态定义：`f[i][j]` 为走到 `[i, j]` 时的不同路径数
- 状态转移：`f[i][j] = f[i - 1][j] + f[i][j - 1]`
- 初始化：当 `i == 0` 或者 `j == 0` 时，只有一条可行路径，即 `f[i][j] = 1`

```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        f = [[0] * n for _ in range(m)]
        for i in range(m):
            for j in range(n):
                if i == 0 or j == 0:
                    f[i][j] = 1
                else:
                    f[i][j] = f[i - 1][j] + f[i][j - 1]
        return f[-1][-1]
```

**运行结果**：
> 执行结果：通过  
> 执行用时：48 ms, 在所有 Python3 提交中击败了20.70% 的用户  
> 内存消耗：13.6 MB, 在所有 Python3 提交中击败了18.58% 的用户

---

## 数学一行解

在前两天的 [[202012061107 118. 杨辉三角|118. 杨辉三角]] 一题中用到的 `math.comb` 又派上了用场。这么解的思路是，机器人一共要走 `m + n - 2` 步，其中有 `m - 1` 步是向下走的，有 `n - 1` 步是向右走的，只需要从 `m + n - 2` 步挑选出 `m - 1` 步向下走，这样得到的方案总数就是不同路径数。

```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        return math.comb(m + n - 2, m - 1)
```

**运行结果**：

> 执行结果：通过  
> 执行用时：28 ms, 在所有 Python3 提交中击败了98.97% 的用户  
> 内存消耗：13.6 MB, 在所有 Python3 提交中击败了22.81% 的用户

---

`2020.12.09`

![公众号](https://cdn.jsdelivr.net/gh/jpch89/PicBed/img/202010301058%20%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%AE%A3%E4%BC%A0%E5%9B%BE%2001.png)
