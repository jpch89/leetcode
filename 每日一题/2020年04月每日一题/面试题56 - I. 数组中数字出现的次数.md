# 面试题56 - I. 数组中数字出现的次数

---

## 题目描述

一个整型数组 `nums` 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是 `O(n)`，空间复杂度是 `O(1)`。

**示例 1：**

> 输入：nums = [4,1,4,6]
> 输出：[1,6] 或 [6,1]

**示例 2：**

> 输入：nums = [1,2,10,4,1,4,3,3]
> 输出：[2,10] 或 [10,2]

**限制：**

> 2 <= nums <= 10000

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

---

## 使用 `list.sort()` 方法排序

借助列表的 `sort()` 方法进行升序排序，然后再查找只出现一次的数字，即“先排序，后查找”。

由于 `list.sort()` 方法底层使用了 `TimSort` 算法，它的最坏时间复杂度是 `O(nlogn)`，空间复杂度是 `O(n)`，所以本解法实际上并不符合题目要求。

查找的过程就是简单的遍历，时间复杂度为 `O(n)`。

```python3
class Solution:
    def singleNumbers(self, nums: List[int]) -> List[int]:
        n = len(nums)
        nums.sort()
        i = 0
        ans = []

        while i < n - 1:
            if nums[i] == nums[i + 1]:
                i += 2
                continue
            ans.append(nums[i])
            if len(ans) == 2:
                break
            i += 1

        if len(ans) == 1:
            ans.append(nums[-1])

        return ans

```

运行结果如下：
> 执行结果：通过
> 执行用时 :60 ms, 在所有 Python3 提交中击败了66.00% 的用户
> 内存消耗 :14.8 MB, 在所有 Python3 提交中击败了100.00%的用户

---

## 借助 `collections.Counter` 的两行解法

`collections.Counter` 是 `dict` 的子类，所以算是字典解法。

本解法时间复杂度为 `O(n)`，空间复杂度为 `O(n)`，所以实际上也不符合题目要求，但理论上讲比上一个速度要快，也更加简洁。

```python3
class Solution:
    def singleNumbers(self, nums: List[int]) -> List[int]:
        c = collections.Counter(nums)
        return [i for i in c if c[i] == 1]

```

运行结果如下：

> 执行结果：通过
> 执行用时 :60 ms, 在所有 Python3 提交中击败了66.00% 的用户
> 内存消耗 :15 MB, 在所有 Python3 提交中击败了100.00%的用户

---

## 分组异或

这个思路一开始没想到，后来看了题解区才明白。建议事先攻克第 `136` 题，点亮前置技能：使用异或寻找（~~单身狗~~）数组中只出现一次的元素。

首先，我们知道对于数组中只出现一次的元素，可以使用异或得到它。

举个例子，对于数组 `[a, c, a, b, b]` 中所有的元素迭代求异或：

- `a ^ c ^ a ^ b ^ b`
- 由于异或运算满足交换律和结合律，所以上式变换为 `(a ^ a) ^ (b ^ b) ^ c`
- `0 ^ 0 ^ c`，最后得到 `c`

所以我们有了这样的结论：**对数组中所有的元素迭代求异或，可以得到数组中只出现一次的元素。**

但是本题中，一共有两个出现了一次的元素，设它们为 `a` 和 `b`。如果能把它们放到不同的数组中，并且保证数组中的其他元素都出现了两次，这样就得到了两个数组，每个数组都包含只出现一次的元素，就可以通过分别对两个数组中所有的元素迭代求异或，得到 `a` 和 `b` 了。

**如何将 `a` 和 `b` 分在两个不同的数组，并保证数组中其他元素都出现两次呢？**

我们可以先对数组求一次异或，根据异或运算的特性可以知道，得到的结果其实就是 `a ^ b` 的结果，记为 `x`。现在考虑 `x` 的二进制表示 `x1x2...xn` 中，把某一位记作 `xi`。

对于 `xi`：
- 如果 `xi == 1`，说明 `a` 与 `b` 在第 `i` 位上不同
- 如果 `xi == 0`，说明 `a` 与 `b` 在第 `i` 位上相同

我们可以通过位运算找到 `x` 中满足 `xi == 1` 的位数 `i`，把它的取值作为**分组标准**。

（实际上最终找的是一个掩码，而不是位数，找位数速度慢一点）

对于 `nums` 数组中的每一个元素 `n`，我们都根据它的第 `i` 位做判断，如果 `ni == 0` 划到第一组，如果 `ni == 1` 划到第二组：

- 对于出现两次的元素，也就是相同的元素，在它们的二进制表示中，每一位都是相同的，所以根据 `ni` **总是会划分到同一组**。
- 对于只出现一次的元素 `a` 和 `b`，由于 `xi == 1`，说明它们的第 `i` 位一定不同，所以根据 `ni` 这个**分组标准**，它们**一定会被划分到不同组**。

这样就得到两个子数组，每个数组中都包含一个只出现一次的元素，采用我们之前的结论对数组中所有的元素迭代求异或，就能得到 `a` 和 `b` 了。

```python3
class Solution:
    def singleNumbers(self, nums: List[int]) -> List[int]:
        # 异或
        x = functools.reduce(lambda x, y: x ^ y, nums)

        # 掩码
        m = 1
        while x & m == 0:
            m <<= 1
        
        # 初始化两个只出现一次的数
        a = b = 0
        for n in nums:
            if n & m:
                a ^= n
            else:
                b ^= n

        return [a, b]
```

采用这种方法，时间复杂度为 `O(n)`，空间复杂度为 `O(1)`，满足题目要求。

运行结果：

> 执行结果：通过
> 执行用时 :64 ms, 在所有 Python3 提交中击败了52.39% 的用户
> 内存消耗 :14.8 MB, 在所有 Python3 提交中击败了100.00%的用户

---

`2020.4.28`
