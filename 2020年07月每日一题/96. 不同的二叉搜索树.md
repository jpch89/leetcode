# 96. 不同的二叉搜索树

## 题目描述

给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？

**示例:**

```txt
输入: 3
输出: 5
解释:
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
```

来源：力扣（LeetCode）  
链接：<https://leetcode-cn.com/problems/unique-binary-search-trees>  
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

---

## DP

**状态定义**：

- `f[i]` 表示从 `1` 到 `i` 这 `i` 个数能够形成的二叉搜索树的数量。
- 通过进一步观察，其实只要**序列长度**相同，它们能形成的二叉搜索树的数量也是一致的。举个例子，`f[5]` 能表示 `1 ~ 5` 这五个数形成的二叉搜索树的数量，也能够表示 `3 ~ 8` 这五个数形成的二叉搜索树的数量。

**状态转移**：

- 我们可以任选一个数字 `k` 作为根结点，此时只要计算出当前根结点的左子树方案数与右子树方案数，将两者相乘，就可以得到以 `k` 为根结点的能够形成的二叉搜索树的数量。
- 可以用作根结点的 `k` 取值范围从 `1` 到 `n`。
- **初始化**：`f[0] = 1`，没有节点时，能够形成一种方案。如果这里初始化为 `0` 的话，任何数乘以零都是零，这样到后面方案数就会出问题。
- **答案**：`f[n]`，也就是长度为 `n` 的序列能够组成的二叉搜索树的数量。

**代码说明**：

- 外层循环是用来递推的，`f[n]` 依赖于 `f[0] ~ f[n - 1]`，所以要从 `1` 开始往上算。
- 内层循环是用来选取根结点的，根结点从 `1` 到 `i`。

```python
class Solution:
    def numTrees(self, n: int) -> int:
        f = [0] * (n + 1)
        f[0] = 1
        for i in range(1, n + 1):
            for j in range(1, i + 1):
                f[i] += f[j - 1] * f[i - j]
        return f[n]
```

**运行结果：**

> 执行结果：通过  
> 执行用时：28 ms, 在所有 Python3 提交中击败了99.03% 的用户  
> 内存消耗：13.6 MB, 在所有 Python3 提交中击败了5.26% 的用户

---

## 一行解：卡特兰数

```python
class Solution:
    def numTrees(self, n: int) -> int:
        return factorial(2 * n) // factorial(n) // factorial(n + 1)
```

**运行结果**：
> 执行结果：通过  
> 执行用时：40 ms, 在所有 Python3 提交中击败了65.73% 的用户
> 内存消耗：13.7 MB, 在所有 Python3 提交中击败了5.26% 的用户

---

`2020.7.15`
