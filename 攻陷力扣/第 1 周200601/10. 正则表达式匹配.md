# 10. 正则表达式匹配

## 题目描述

给你一个字符串 `s` 和一个字符规律 `p`，请你来实现一个支持 `'.'` 和 `'*'` 的正则表达式匹配。

> `'.'` 匹配任意单个字符
> `'*'` 匹配零个或多个前面的那一个元素

所谓匹配，是要涵盖**整个**字符串 `s` 的，而不是部分字符串。

**说明:**

- `s` 可能为空，且只包含从 `a-z` 的小写字母。
- `p` 可能为空，且只包含从 `a-z` 的小写字母，以及字符 `.` 和 `*`。

**示例 1:**

> 输入:  
> `s = "aa"`  
> `p = "a"`  
> 输出: `false`  
> 解释: `"a"` 无法匹配 `"aa"` 整个字符串。

**示例 2:**

> 输入:  
> `s = "aa"`  
> `p = "a*"`  
> 输出: `true`  
> 解释: 因为 `'*'` 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 `'a'`。因此，字符串 `"aa"` 可被视为 `'a'` 重复了一次。

**示例 3:**

> 输入:  
> `s = "ab"`  
> `p = ".*"`  
> 输出: `true`
> 解释: `".*"` 表示可匹配零个或多个（`'*'`）任意字符（`'.'`）。

**示例 4:**

> 输入:  
> `s = "aab"`  
> `p = "c*a*b"`  
> 输出: `true`  
> 解释: 因为 `'*'` 表示零个或多个，这里 `'c'` 为 `0` 个, `'a'` 被重复一次。因此可以匹配字符串 `"aab"`。

**示例 5:**

> 输入:  
> `s = "mississippi"`  
> `p = "mis*is*p*."`  
> 输出: `false`

来源：力扣（LeetCode）  
链接：<https://leetcode-cn.com/problems/regular-expression-matching>  
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

---

## 递归

**基线条件：**

- 如果 `p` 和 `s` 都为空字符串，返回 `True`
- 如果 `p` 为空串，`s` 不为空串，返回 `False`

**递归条件：**

- 先进行简单的字母或点号匹配，把条件记为 `char_dot`。
- 如果 `s` 不为空，并且 `p[0]` 等于 `s[0]` 或者 `'.'`，那么字母点号匹配成功，否则字母点号匹配失败。
- 如果 `p` 有两个以上的字符，且第二个字母是星号，则开始星号匹配：
  - 可以匹配零次
  - 或者匹配一次
- 当 `p` 只有一个字符，只能进行字母或点号匹配。
- 或者当 `p` 有两个以上的字符，但第二个字符不是 `'*'`，也只能进行字母或 `'.'` 的匹配。

```python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        # 如果 p 和 s 都为空串，匹配成功
        # 如果 p 为空串，s 不为空串，匹配失败
        if p == '':
            return s == ''

        # 下面都是 p 不为空的情况
        # char_dot 条件：用于判断是否能匹配字母或 '.'
        # 当 s 不为空，且 p[0] 等于 s[0] 或者 '.' 时，可以成功匹配字母或 '.'
        char_dot =  bool(s) and p[0] in (s[0], '.')

        # 如果 p 有两个以上的字符，并且第二个字符是 '*'，开始星号匹配
        if len(p) >= 2 and p[1] == '*':
            return (
                # 匹配零次，跳过一个“字符星号”组合。
                self.isMatch(s, p[2:])
                # 或者要求 char_dot 条件满足，即成功匹配一次
                # 并且剩余部分也要全部匹配
                # （比如 'aaa' 和 'a*' 最终会变成 '' 和 'a*' 而成功匹配）
                or char_dot and self.isMatch(s[1:], p)
            )
        # 否则
        # 1. p 只有一个字符，只能进行字母或 '.' 的匹配
        # 2. p 有两个及以上的字符，但是第二个字符不是 '*'，也只能进行字母或 '.' 的匹配
        else:
            # char_dot 满足时进入递归，否则短路，直接返回 char_dot 的 False
            return char_dot and self.isMatch(s[1:], p[1:])

```

**运行结果：**

> 执行结果：通过  
> 执行用时 :1348 ms, 在所有 Python3 提交中击败了32.40% 的用户  
> 内存消耗 :13.7 MB, 在所有 Python3 提交中击败了6.82%的用户

**第二次自己写的解法**：

没有别人的解法简单，但是比较容易懂，上面那个解法逻辑有点复杂。

```python3
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        np = len(p)

        # p 为空时，必须 s 也为空，则成功匹配
        if not np:
            return not s

        # p 有值，s 为空
        if not s:
            if np >= 2 and p[1] == '*':
                return self.isMatch(s, p[2:])
            return False

        # p 有值，s 有值
        # first 判断 p[0] 是否等于 s[0]
        first = True if p[0] in (s[0], '.') else False

        # 如果 p 就剩一个字符
        if np == 1:
            return self.isMatch(s[1:], p[1:]) if first else False

        # p 至少有两个字符，且 p[1] 是星号
        if p[1] == '*':
            if first:
                # 可以把 s 的第一个字符匹配掉，也可以跳过 p 的字符星号组合
                # 即可以匹配，也可以不匹配
                return self.isMatch(s[1:], p) or self.isMatch(s, p[2:])
            # 第一个字符不匹配，跳过 p 中的字符星号组合
            return self.isMatch(s, p[2:])

        # p 至少有两个字符，且 p[1] 不是星号
        return self.isMatch(s[1:], p[1:]) if first else False

```

**运行结果**：

> 执行结果：通过  
> 执行用时：1204 ms, 在所有 Python3 提交中击败了36.65% 的用户  
> 内存消耗：13.7 MB, 在所有 Python3 提交中击败了6.82% 的用户

---

## 更新记录

- `2020.6.5` 初稿
- `2020.6.20` 添加了第二次自己做出来时的解法
